1. 手动实现自定义 RPC 框架。

2. 改造自定义 RPC 框架：
- 将服务端写死查找接口实现类变成泛型和反射；
- 将客户端动态代理改成 AOP，添加异常处理；
- 使用 Netty+HTTP 作为 client 端传输方式。

3. （选做☆☆））升级自定义 RPC 的程序：
- 尝试使用压测并分析优化 RPC 性能；
- 尝试使用 Netty+TCP 作为两端传输方式；
- 尝试自定义二进制序列化；
- 尝试压测改进后的 RPC 并分析优化，有问题欢迎群里讨论；
- 尝试将 fastjson 改成 xstream；
- 尝试使用字节码生成方式代替服务端反射。

4. （选做）RPCfx1.1: 给自定义 RPC 实现简单的分组（group）和版本（version）。
5. （选做）RPCfx2.0: 给自定义 RPC 实现：
基于 ZooKeeper 的注册中心，消费者和生产者可以根据注册中心查找可用服务进行调用（直接选择列表里的最后一个）。
当有生产者启动或者下线时，通过 KooKeeper 通知并更新各个消费者，使得各个消费者可以调用新生产者或者不调用下线生产者。

6. （挑战☆）在 2.0 的基础上继续增强 RPCfx 实现：

3.0: 实现基于 ZooKeeper 的配置中心，消费者和生产者可以根据配置中心配置参数（分组，版本，线程池大小等）。
3.1：实现基于 ZooKeeper 的元数据中心，将服务描述元数据保存到元数据中心。
3.2：实现基于 Etcd/Nacos/Apollo 等基座的配置 / 注册 / 元数据中心。

7. （挑战☆☆）在 3.2 的基础上继续增强 RPCfx 实现：

4.0：实现基于 Tag 的简单路由；
4.1：实现基于 Random/RoundRobbin 的负载均衡 ;
4.2：实现基于 IP 黑名单的简单流控；
4.3：完善 RPC 框架里的超时处理，增加重试参数。

8. （挑战☆☆☆）在 4.3 的基础上继续增强 RPCfx 实现：

5.0：实现利用 HTTP 头跨进程传递 Context 参数（隐式传参）；
5.1：实现消费端 Mock 一个指定对象的功能（Mock 功能）；
5.2：实现消费端可以通过一个泛化接口调用不同服务（泛化调用）；
5.3：实现基于 Weight/ConsistentHash 的负载均衡 ;
5.4：实现基于单位时间调用次数的流控，可以基于令牌桶等算法。

9. （挑战☆☆☆☆）：压测，并分析调优 5.4 版本。
